\t  =>空格
\n =>换行
\\ =>\符号
\' =>'符号


import java.util.Scanner;

public class BooleanTest{
  static Scanner in = new Scanner(system.in);
  public static void main(string []args) {
      int num = 0;
      boolean bool;
      System.out.println("Type 0 if you finish your hw, 1 for don't");
      num = in.nextInt();
      if( num == 0) boolean = ture;
      else boolean = false;
  }
}

DataTypeConvert
int num = (int)0.0


char[] 的默认为“ ” 


public修饰的属性可以被任何地方创建的对象直接访问
缺省修饰的属性可以在同一个包内被创建的对象直接访问
private修饰的属性只可以在本类中访问

static修饰的属性是类属性，属于类的特征，其值被所有属于此类的对象共享
static属性规范使用类名进行访问
Student.feature
student.feature //不提倡


构造方法的第一作用是用来创建对象
使用带参数的构造器实现在创建对象时对其进行初始化（为成员属性赋值）
this关键字在构造器及实例方法，代表指向当前对象（当局部变量和成员变量名称相同时必须用this）
public class Employee{

  private Sring name;
  private int age;
  
  public Employee(String name){ //构造器
    this.name = name;
  }
  
  public Employee(String name, int age){ 
    this.name = name;
    this.age = age;
  }
  
  public Employee(){ //公共无参构造器

  }
  
  public void intro(){//method
    System.out.println("I'm " + name);
  
  }
  
}


public class Test{
  public static void main(String[] args){
    Employee e1 = new Employee("张三");
    e1.intro();
  }

}



//使用实例方法例子

public class Dog{
  private String color;
  public Dog(String c){color = c};//构造器。可以创建新的对象，并通过带参数的构造器进行初始化。
  public viod setColor(String c){ this.color =  c;} //使用公共的set方法实现对私有属性进行设置值
  public String getColor(){return this.color;}//使用公共的get方法实现对私有属性的获取

} 
public class DataManger{
    public void changeColor(Dog dog){
        dog.setColor("Black");
    }
}

public class TestDog{
    public static void main(String[] args){
        Dog dog = new Dog("Brown");
        
        System.out.println(dog.getColor()); //此时未改变颜色，为棕色
        dog.changeColor(dog);
        System.out.println(dog.getColor()); //此时未改变颜色，为黑色
    }

}


//使用静态方法
public class AreaProvider{
    private int n;
    
    public static double countArea(double h, double d){ 
    System.out.print(n); //错误，静态方法（类方法）不允许访问实例属性，不能调用实例方法，不能使用this关键字
    int n = 0;
    System.out.print(n); //正确，方法之内声明的变量不属于成员实例属性
    return h * d;
    
    }
}

public class TestStaticMethod{
    AreaProvider.countArea(34.5, 123.78);
    
    AreaProvider area1 = new AreaProvider();
    area1 = countArea(23, 24); // 不推荐，不使用实例访问静态方法
    
}


//方法重载，与访问修饰符，是否静态，返回类型无关
public class AreaProvider{
    private int n;
    
    public static double countArea(double h, double d){ 
    return h * d;
    } //长方形面积
    public static double countArea(double h, double a, double b){ 
    return (a + b) * h / 2;
    }//梯形面积
    public static double countArea(double r){ 
    return Math.pi*r*r;
    }
}

//继承
final不能被继承


//创建一个父类computer
public class Computer{
  private Sting name;

  public double count(double a, double b){return a + b;}
  
  public Computer(){}
  
  public Computer(String name){this.name = name;}//当创建了一个有参构造器时，默认的无参构造器会被覆盖
  
  public String getName(){return name;}//通过public的get方法得到private的name
  
  private void show(){System.out.println("I'm " + name);}
  
  public static void staticMethod() {System.out.println("This is stasic Method");}
  
}


//创建第一个子类Watch
public class Watch extends Computer{

   public Watch(String name){
    //System.out.println(name); // 报错。没有执行super时子类构造还没有调用父类构造器，因此子类构造器还没有产生
    super(name); //子类中的构造器super关键字永远是调用父类中的构造器，从而创建父类构造器
    //System.out.println(name); //正确。super关键字必须位于子类构造器的第一行
   }
   
   public void displayTime(){
      System.out.println(new SimpleDateFormat("yyyy-MM-dd").format(new Date()));
   }
   //重写
   @override
   public double count(double n, double m){//访问修饰符不得低于父类，返回类型，方法名，参数类型，参数数量不得改变。对于final类型的方法不能重写。
      double res = supper.count(n, m);//加上了super关键字，则访问父类的count。否则会访问子类的count，从而导致死循环。
      return (n - m)/res; //最终结果是(n - m)/(n + m);
   }
   
   //静态方法的覆盖
   public static void staticMethod() {
      super.staticMethod();//报错，super不允许出现在static中
      Computer.staticMethod();//正确。子类的静态方法中使用父类类名，可以访问父类资源。
      System.out.println("New stasic Method");
   }
}

//创建一个子类MobilePhone
public class MobilePhone extends Computer{
   public void message(String content){
      System.out.println("内容： " + content);
   }

}


//对于Wacth的测试
public class Test{
  public static void main(String[] args){
      watch.displayTime();
      watch.count(1.1, 2.2); // 3.3
      Watch watch = new watch("字节");
      System.out.println(watch.getName()); //字节
      Watch.staticMethod();//正确。静态方法可以通过类方法调用。如果子类中覆盖了父类的类方法，则调用子类的类方法
  }

}


//对于MobilePhone的测试
public class Test2{
  public static void main(String[] args){
      Computer computer = new MobilePhone(); //上转型对象（实例是子类的，类型是父类的）
      System.out.println(computer.count(23, 45);) //68 上转型对象可以直接调用父类中的方法
      computer.message("Hello"); //报错。因为上转型对象不能访问子类中新添加的属性和方法
      ((MobilePhone)computer).message("Hello");//正确。上转型对象可以强制转换为实际的子类类型
      
      MobilePhone mp = new MobilePhone();
      mp.messagee("Hello"); //正确
      
      mp.show();//错误。 show方法在父类中为private，子类无法继承。
  }

}

