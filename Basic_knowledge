\t  =>空格
\n =>换行
\\ =>\符号
\' =>'符号
 
 
 字符串用"", char 用''

import java.util.Scanner;

public class BooleanTest{
  static Scanner in = new Scanner(system.in);
  public static void main(string []args) {
      int num = 0;
      boolean bool;
      System.out.println("Type 0 if you finish your hw, 1 for don't");
      num = in.nextInt();
      if( num == 0) boolean = ture;
      else boolean = false;
  }
}

DataTypeConvert
int num = (int)0.0


char[] 的默认为' '


public修饰的属性可以被任何地方创建的对象直接访问
缺省修饰的属性可以在同一个包内被创建的对象直接访问
private修饰的属性只可以在本类中访问

static修饰的属性是类属性，属于类的特征，其值被所有属于此类的对象共享
static属性规范使用类名进行访问
Student.feature
student.feature //不提倡


构造方法的第一作用是用来创建对象
使用带参数的构造器实现在创建对象时对其进行初始化（为成员属性赋值）
this关键字在构造器及实例方法，代表指向当前对象（当局部变量和成员变量名称相同时必须用this）
public class Employee{

  private Sring name;
  private int age;
  
  public Employee(String name){ //构造器
    this.name = name;
  }
  
  public Employee(String name, int age){ 
    this.name = name;
    this.age = age;
  }
  
  public Employee(){ //公共无参构造器

  }
  
  public void intro(){//method
    System.out.println("I'm " + name);
  
  }
  
}


public class Test{
  public static void main(String[] args){
    Employee e1 = new Employee("张三");
    e1.intro();
  }

}



//使用实例方法例子

public class Dog{
  private String color;
  public Dog(String c){color = c};//构造器。可以创建新的对象，并通过带参数的构造器进行初始化。
  public viod setColor(String c){ this.color =  c;} //使用公共的set方法实现对私有属性进行设置值
  public String getColor(){return this.color;}//使用公共的get方法实现对私有属性的获取

} 
public class DataManger{
    public void changeColor(Dog dog){
        dog.setColor("Black");
    }
}

public class TestDog{
    public static void main(String[] args){
        Dog dog = new Dog("Brown");
        
        System.out.println(dog.getColor()); //此时未改变颜色，为棕色
        dog.changeColor(dog);
        System.out.println(dog.getColor()); //此时未改变颜色，为黑色
    }

}


//使用静态方法
public class AreaProvider{
    private int n;
    
    public static double countArea(double h, double d){ 
    System.out.print(n); //错误，静态方法（类方法）不允许访问实例属性，不能调用实例方法，不能使用this关键字
    int n = 0;
    System.out.print(n); //正确，方法之内声明的变量不属于成员实例属性
    return h * d;
    
    }
}

public class TestStaticMethod{
    AreaProvider.countArea(34.5, 123.78);
    
    AreaProvider area1 = new AreaProvider();
    area1 = countArea(23, 24); // 不推荐，不使用实例访问静态方法
    
}


//方法重载，与访问修饰符，是否静态，返回类型无关
public class AreaProvider{
    private int n;
    
    public static double countArea(double h, double d){ 
    return h * d;
    } //长方形面积
    public static double countArea(double h, double a, double b){ 
    return (a + b) * h / 2;
    }//梯形面积
    public static double countArea(double r){ 
    return Math.pi*r*r;
    }
}

//继承
final不能被继承


//创建一个父类computer
public class Computer{
  private Sting name;

  public double count(double a, double b){return a + b;}
  
  public Computer(){}
  
  public Computer(String name){this.name = name;}//当创建了一个有参构造器时，默认的无参构造器会被覆盖
  
  public String getName(){return name;}//通过public的get方法得到private的name
  
  private void show(){System.out.println("I'm " + name);}
  
  public static void staticMethod() {System.out.println("This is stasic Method");}
  
}


//创建第一个子类Watch
public class Watch extends Computer{

   public Watch(String name){
    //System.out.println(name); // 报错。没有执行super时子类构造还没有调用父类构造器，因此子类构造器还没有产生
    super(name); //子类中的构造器super关键字永远是调用父类中的构造器，从而创建父类构造器
    //System.out.println(name); //正确。super关键字必须位于子类构造器的第一行
   }
   
   public void displayTime(){
      System.out.println(new SimpleDateFormat("yyyy-MM-dd").format(new Date()));
   }
   //重写
   @override
   public double count(double n, double m){//访问修饰符不得低于父类，返回类型，方法名，参数类型，参数数量不得改变。对于final类型的方法不能重写。
      double res = supper.count(n, m);//加上了super关键字，则访问父类的count。否则会访问子类的count，从而导致死循环。
      return (n - m)/res; //最终结果是(n - m)/(n + m);
   }
   
   //静态方法的覆盖
   public static void staticMethod() {
      super.staticMethod();//报错，super不允许出现在static中
      Computer.staticMethod();//正确。子类的静态方法中使用父类类名，可以访问父类资源。
      System.out.println("New stasic Method");
   }
}

//创建一个子类MobilePhone
public class MobilePhone extends Computer{
   public void message(String content){
      System.out.println("内容： " + content);
   }

}


//对于Wacth的测试
public class Test{
  public static void main(String[] args){
      watch.displayTime();
      watch.count(1.1, 2.2); // 3.3
      Watch watch = new watch("字节");
      System.out.println(watch.getName()); //字节
      Watch.staticMethod();//正确。静态方法可以通过类方法调用。如果子类中覆盖了父类的类方法，则调用子类的类方法
  }

}


//对于MobilePhone的测试
public class Test2{
  public static void main(String[] args){
      Computer computer = new MobilePhone(); //上转型对象（实例是子类的，类型是父类的）
      System.out.println(computer.count(23, 45);) //68 上转型对象可以直接调用父类中的方法
      computer.message("Hello"); //报错。因为上转型对象不能访问子类中新添加的属性和方法
      ((MobilePhone)computer).message("Hello");//正确。上转型对象可以强制转换为实际的子类类型
      
      MobilePhone mp = new MobilePhone();
      mp.messagee("Hello"); //正确
      
      mp.show();//错误。 show方法在父类中为private，子类无法继承。
  }

}


//抽象类，一种用于被继承的类
//抽象父类 Animal
public abstract class Animal{//抽象类中也可以包含非抽象方法
  public abstract void run(); //抽象方法，可以用public和protect，但是不能用private，因为private不能被子类调用。
  // 注意： 不能使用final，static。抽象类不能实例化。
}


//普通子类Lion
public class Lion extends Animal{//用普通类继承抽象类时，必须对抽象类的所有方法提供实现
    @override
    public void run(){
      System.out.println("This is a lion");
   } 
}


//抽象子类 Mammal
public abstract Mammal extends Animal{//抽象子类可以不实现父类中的抽象方法，也可以对抽象方法进行实现
    public abstract void lactation();//在抽象子类中可以继续添加新的抽象方法，也可以添加非抽象方法

}

//测试
public class TestAbstract{
    public static void main(Spring[] args){
        Animal animal = new Animal(); //错误。抽象类自身不能实例化
        Animal animal2 = new Lion();//正确。抽象类的实例化属于上转型对象。
        Animal animal2 = new Mammal();//错误
    }
}




//接口
public abstract interface Computer{
    public static final int MAX_NUM = Interger.MAX_VALUE;
    //Java接口只允许定义公共的静态常量，可以省略public static final修饰符
    
    public abstract double count(double a, double b);
    //接口中值允许定义public的抽象方法，可以省略public和abstract
}

//接口的继承
public interface Clock extends Computer{
    void showSystemDateTime();//在子接口中添加了新的抽象定义
}


public class Mulity implements Computer{
    @Override
    public double count(count a, count b){
        return a * b; 
    }
    
    @Override
    public void showSystemDateTime(){
    System.out.print("Time");
    /**
        while(true){
            Date time = new Date();
            String timeString = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(time);
            try{Thread.sleep(1000);}
            catch(InterrutedException e){e.printStackTrace();}
            */
            
        }
    }

}

public TestInterface{
  //Computer computer = new Computer(); //错误。接口自身不能实例化
  Computer computer = new Mulity();//需要借助非抽象的上转型实例化。
  double res = computer.count(2, 3);
  computer.showSystemDateTime();
  System.out.println(res); //6

}




//内部类和局部类

public interface Computer{
  void useComputer(double a, double b);//接口一定是抽象类
}

public class NotebookComputer implements Computer{
    @override//普通类使用接口，要对接口功能进行实现
    public void useComputer(double num0, double num1){
    
        //Memory memory = null; //错误，内部类还未创建
        class Memory{ //局部类不能加访问修饰符，不能加static
            public void store(double a, double b){
                System.out.print("These two numbers are in memory right now")
            }
        }
        Memory memory = new Memory();  //正确，创建局部类对象
        memery.store(num0, num1);
        
        
        Hoard hoard = new NoteBookComputer.Hoard(); //创建了一个本地的静态内部类对象
        hoard.displaySelf();//调用内部静态方法
        //因为私有的静态类只能在本类中使用，所以强行把它写到了接口里
    }
    
    public class Cpu{ //普通内部类
        public void handleData(){
          System.out.println("I'm handlind data!")
        }
    }
    
    private static class Hoard{//私有的静态内部类
        public void displaySelf(){
          System.out.print("This is hoard!")
        }
    }
}

//普通内部类的测试
public class TestInnerClass{
  public static void main(String[] args){
    cpu = new Cpu(); //错误，要先调用外部类
    NotebookComputer nc = new NotebookComputer();
    cpu = nc.new Cpu();//正确，先调用了外部类，再调用内部类
    
    cpu = new New NotebookComputer().new Cpu();//正确。将上面两句合成一句
    
    cpu.handlData(); // I'm handlind data!
    
    //局部类的测试
    nc.useComputer(1,2); //These two numbers are in memory right now  This is hoard!
  }

}

//匿名类

//定义一个职员类，这个职员类可以利用接口进行工作
public class Staff{
    public void useComputerWorking(Computer computer, double n, double m){
        computer.useComputer(n , m);
    }

}

public class TestHiddenClass{
    public static void main(String[] args){
        Staff mark = new Staff();
        double a = 1.0;
        double b = 2.0;
        mark.useComputerWorking(new Computer(){
          @Override
          public void useComputer(double a, double b){
             double res = a + b;
             System.out.print("计算结果是"+res);
          }//匿名类对象
        }, a, b);
        
        //如果不想使用匿名类，可以先对接口进行override，然后使用useComputerWorking来进行Staff的计算
//        Computer computer = new Computer() {
//            @Override
//            public void useComputer(double a, double b) {
//                System.out.print("计算结果是" + (a + b));
//            }
//        };
//        mark.useComputerWorking(computer, a, b);
        
    }
}



//静态块

public class Location{

  public static final int EAST;
  public static final int WEST;
  public static final int SHOUTH;
  public static final int NORTH;
  
  public double distance;
  
  
  static{ //静态代码块，允许赋值和调用静态方法
     EAST = 0;
     WEST = 1;
     SOUTH = 2;
     NORTH = 3;
     display();
     displayDistance(distance); //错误。不能在静态块中引用非静态方法，不能访问非静态字块
     
     class B{} //静态中可以定义内部类
     
     interface B{}//错误，静态块中不许使用接口
  }
  
  public static void display(){
      System.out.println("您的当前默认位置是" + NORTH);
  
  }
  
  private void displayDistance(double distance){
      
  }
  
  public Location(double distance){
    this.distance = distance;
    System.out.println("调用构造器，创建对象");
  }
}


public class TestSta1{
    public static void main(String[] args){
        int location = Location.SOUTH; //您的当前默认位置是3
        int location = Location.EAST;//静态代码块和类的加载只会被加载一次
    }

}


public class TestSta2{
    public static void main(String[] args){
        Location location = new Location(233.33); //您的当前默认位置是3  调用构造器，创建对象
        //静态代码块在静态初始化后与调用构造器之前加载
    }
}


//object类(顶级父类)
public interface BaseInterface{
  Object superMethod(Object obj);//可以存入任何类型
}

public class BaseInterfacesImp implements BaseInterface{
    public Object superMethod(Object obj){
        int []ints = (int[])obj;
        return ints.length > 1 ? ints[0] + ints[1] : 0; //注意要进行强制转换
    }

}

public class Test{
    piblic static void main(String[] args){
        BaseInterface baseInter = new BaseInterfacesImp();
        int []ints = {34, 25}
        int sum = (Integer)(baseInter.superMethod(ints));
        System.out.println(sum); // 59
    }

}



//toString()
public class Users{
    private String id;
    private String name;
    private int age;
    
    public String getId(){
      return id;
    }
    public void setId(String id){
      this.id = id;
    }
    public String getName(){
      return name;
    }
    public void setName(String name){
      this.name = name;
    }
    public void setAge(int Age){
      this.age = age;
    }
    public int getAge(){
      return age;
    }
    public Users(String id, Srting name, int age){
      this.id = id;
      this.name = name;
      this.age = age;
    }
    public Users(){}
    
    @Override
    public String toString(){
      String begin = '{';
      String end = '}';
      
      begin += "\"";
      begin += "id";
      begin += "\"";
      begin += ":";
      begin += this.getId();
      begin += ",";
      
      begin += "\"";
      begin += "name";
      begin += "\"";
      begin += ":";
      begin += this.getName();
      begin += ",";      
      
      begin += "\"";
      begin += "age";
      begin += "\"";
      begin += ":";
      begin += this.getAge();
      begin += end; 
      
      return begin;

    }

}

public class Test2{
    public static void main(String[] args){
        Users u = new Users("NO1", "Bob", 20);
        System.out.println(u.toString()); //{"id":NO1, "name":Bob, "age":69}
    }
}


//equals
public class Employee implements Cloneable{ //为了克隆，必须使用cloneable接口
    private String id;
    private String name;
    public String getId(){
        return id;
    }
    public void setId(String id){
       this.id = id;
    }
    public String getName(){
        return name;
    }
    public String setName(String name){
        this.name = name;
    }
    public Employee(String id, String name){
        this.id = id;
        this.name = name;
    }
    public Employee(){
        
    }
    @Override
    public boolean equals(Object obj){
        Employee emp = (Employee)obj;
        return this.getId().equals(emp.getId()) ? true : false;
    }
    //clone方法
    @Override
    public Employee clone throws CloneNotSupportedException{
        System.out.println("开始克隆");
        return (Employee)super.cione();
    }
}
public class Test3 {
    public static void main(String[] args){
        Employee emp0 = new Employee("123", "Bob");
        Employee emp1 = new Employee("123", "Alice");
        emp0.equals(emp1); //true
    }
}
//getClass方法
public class Test4 {
    public static void main(String[] args){
        Employee emp0 = new Employee("123", "Bob");
        Class empClass = emp.getClass(); 
        //使用class对象获取当前对象的类的完全限定名称
        empclass.getName(); //可以得到类名，比如com.szb.entity
    }
}

//hashCode方法
public class Test5 {
    public static void main(String[] args){
        Users u0 = new Users("NO12", "Jack", 40 );
        Users u1 = new Users;
        User u2 = u0;
        u0.hashCode();
        u1.hashCode();
        u2.hashCode(); //u0和u2应该相同
    }
}

//clone方法
public class Test6 {
    public static void main(String[] args){
        Employee e1 = new Employee("1", "A");
        try{
             Employee cloneEmp = e1.clone();
             System.out.println("当前对象与克隆对象是否相等" + (e1 == cloneEmp)); //false
             System.out.println("当前对象属性" + e1.getId()+"/t"+e1.getName()); //1，A
             System.out.println("克隆对象属性" + cloneEmp.getId()+"/t"+cloneEmp.getName()); //1，A
        }catch(CloneNotSupportedException e){
            e.printStackTrace();
        }
    }
}

//Integer包装类
public final class Employee{
    private Integer id; //使用包装类代替int
    public Employee(Integer id){
        this.id = id;
    }
    public Employee(){
    }
    public Integer getId(){
        return id;
    }
    public Integer setId(Integer id){
        this.id = id;
    }
} 

public class TestInteger{
    public static void main(String[] args){
        Employee emp = new Employee();
        Employee emp2 = new Employee();
        
        Integer intObj = new Integer(24);
        emp.setId(intObj);
        
        Integer intObj2 = new Integer("25");//可以用int，也可以用string
        emp.setId(intObj2);
        
        //compareTo方法比较大小
        emp.getId().compareTo(emp2.getId());           //-1, 因为emp小于emp2
        emp2.getId().compareTo(emp.getId());           //1, 因为emp2大于emp
        new Integer(100).compareTo(new Integer(100));  //0, 因为相等
        
        //intValue方法
        emp.getId().intValue();       //24 
        
        //parseInt方法，将字符串转为值类型。
        String pwd = '123456';
        int pwdInt = Integer.parseInt(pwd);
        
        //parseInt重载方法
        Integer.parseInt("10111", 2)    //此处10111为二进制，用该方法可以转成十进制，为23
        Integer.parseInt("14174", 8)    //6268
        Integer.parseInt("0A8FC", 16)   //43260
        
        
    }
}


Integer.MAX_VALUE //2147483647
Integer.MIN_VALUE //-2147483648
Integer.BYTES    //4
Integer.SIZE     //32

//toBinaryString方法，返回一个二进制的字符串
public static class IntergerParse(){
    public String formIntegerToStringByArg(int target, int tag){
        if(tag == 2) return Integer.toBinaryString(target);
        else if(tag == 8) return Integer.toOctalString(target);
        else if(tag == 16) return Integer.toHexString(target);
        else return Integer.toBinaryString(target);
    }
}

public class TestInteger2{
    public static void main(String[] args){
        int num = 2390;
        IntegerParse.formIntegerToStringByArg(num, 2);    //100101010110
        IntegerParse.formIntegerToStringByArg(num, 8);    //4526
        IntegerParse.formIntegerToStringByArg(num, 16);   //956
        IntegerParse.formIntegerToStringByArg(num, 5);    //100101010110
    }
}


//valueOf方法，把给定的参数转化成对象类型
//toString方法
public class TestValueOfMethod{
    public static void main(String[] args){
        int num = 1234;
        Integer intObj0 = Integer.valueOf(num); 
        System.out.println(intObj0.intValue());   //1234。注意，intValue是把Integer转为int
        
        Integer.valueOf("345").intValue;   //Integer.valueOf("345")是把字符串转成integer 
        
        Srting str = "1011010";
        Integer intObj2 = Integer.valueOf(srt, 2); //90.valueOf可以将二进制转为十进制，其实是调用了parseInt方法
        
        Integer intObj = Integer.valueOf(156);
        intObj.toString().length(); //3
        intObj.toString(2);//不提倡。在toString没有参数的时候，是由对象进行调用的（调用的函数没有static）
        Integer.toString(2);//有参数的时候，调用函数有static，是静态重载，应该用类进行调用
        Integer.toString(intObj， 2); //10011100.将intObj转为二进制
    }
}


//Character包装类
public class Test{
    public static void main(String[] args){
        Character charObj = new Character('A');
        Character charObj2 = Character.valueOf('中'); //用静态方式创建
        
        CharacterManager.equal(Character.valueOf('A')， Character.valueOf('B')); //第二个大
    }
}

//Character的实例方法：charValue(), compareTo(), toString()
//compareTo()方法
public static class CharacterManager{ //跟实例无关，只是一个函数就可以使用static
    public String equal(Character ch0, Character ch1{
        if(ch0.compareTo(ch1) == 0) return "相等";
        else if(ch0.compareTo(ch1) == 1) return "第一个大";
        else return "第二个大";
    }
    
    //统计密码中有多少字母，数字，大写字母，小写字母，非数字且非英文字符
    public static void validatePassword(char[] passArr){
      int num0 = 0; //数字
      int num1 = 0; //字母
      int num2 = 0; //大写
      int num3 = 0; //小写
      int num4 = 0; //非数字且非英文字符
      
      for(int i = 0; i < passArr.length; i++){
         if(Character.isLetter(passArr[i])) ++num1;
         if(Character.isDigit(passArr[i])) ++num0;
         if(Character.isUpperCase(passArr[i])) ++num2;
         if(Character.isLowerCase(passArr[i])) ++num3;
         if(!Character.isLetterOrDigit(passArr[i])) ++num4;
      }
    }
    
    //删除空格
    public static String dropSpaceChar(char []passArr){
      String str = "";
      for(int i = 0; i < passArr.length; i++){
        if(!Character.isWhitespace(passArr[i])){
          str + passArr[i];
        }
      }
          return str;
    }
    
     //改成大写or小写
     public static final int UPPER=1;
     public static final int LOWER=0;
    public static char[] toUpperCaseOrLowerCase(char []passArr, int tag){
      for(int i = 0; i < passArr.length; i++){
        if(tag == UPPER){ //当tag为1的时候，即为UPPER，需要改成大写
          passArr[i] = Character.toUpperCase(passArr[i]);
        }
        else passArr[i] = Character.toLowerCase(passArr[i]);
      }
          return passArr;
    }
}


//Character的静态方法：isDefined(int ch), isDigit(int ch), isLetter(int ch), isLetterOrDigit(int ch), isLowerCase(int ch), isUpperCase(int ch), isWhitespace(int ch), toLowerCase(int ch), toUpperrCase(int ch)
public class Test2{
    public static void main(String[] args){
       char []pwd = {'T','9','0','x',' ','_','4,'n'};
       
       CharacterManager.validatePassword(pwd);
       
       CharacterManager.dropSpaceChar(pwd);
       
       System.out.print(new String(CharacterManager.toUpperCaseOrLowerCase(pwd, CharacterManager.LOWER)));
    }
}

//system类
System.out
System.in
System.err
public static void exit(int status) //退出程序
public static void gc() //垃圾回收，可以调用，但不一定马上执行
public static long currentTimeMills() //获取当前系统时间，毫秒表示
public static Properties getProperties()//获取当前系统map集合
public static String getProperties() //按照给定的名称获取当前系统属性，字符串表示
public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)//复制数组
public static Map<String, String> getenv()//获取当前JVM所在本地系统信息视图

public class void main(String[] args){
  Users [] userList = new Users[10000];
  long begin = System.currentTimeMills(); //开始时间
  for(int i = 0; i < 10000; ++i){userList[i] = new Users("用户" + i);}
  long end = System.currentTimeMills(); //结束时间
  (end - begin) / 1000 //储存对象所需时间，单位为秒
}

public class Test{
  public class void main(String[] args){
    Properties pors = System.getProperties();
    System.out.println(pros.toString());
    
    int []srcs = {0,1,2,3,4,5,6,7,8,9};
    int[]dest = new int[srcs.length - 2];
    System.arraycopy(scr, 1, dest, 0 ,dest.length); //1 2 3 4 5 6 7 8\
    
    //利用System获取本地计算机信息
    Map<String, String> maps = System.getenv();
    Set<String> keys = maps.keySet();
  }
}


//Math类
public static final double E
public static final double PI
public static double abs(int|long|double num)
public static double cbrt(double num) //立方根
public static double ceil(double num) //加一法取整
public static double floor(double num) // 去尾法取整
public static double max(double a, double b)
public static double min(double a, double b)
public static double pow(double a, double b) //a的b次幂
public static double random() //0.0 - 1.0的随机数


//String类
public String()
public String(char[] chars, int offset, int count) //chars:从其他char[]创建string， offset：从哪一个开始， count：要几个


public class TestCreateStringObject{
   public static void main(String[] args){
      String dec = "Abc";
      String newDec = new String(dec);
      
      System.out.println(dec.equals(newDec)); //true string的equals用来判断内容是否相同
      System.out.println(dec == newDec); //false,地址不同
      
      char [] chs = {'2',34, 'A'};
      Sring str = new String(chs);
      System.out.println(str); //2"A
      
   }
}

//常用方法
public char charAt(int index)
public int compareTo(String target)
public boolean equals(String target)
public boolean equalsIgnoreCase(String target)
public boolean endsWith(String suffix)
public boolean startsWith(String prefix)
public Sting trim()
public int indexOf(int ch)
public int indexOf(int ch, int fromIndex) //ch要查找的目标，fromIndex: 从什么地方开始
public int indexOf(String target)
public int indexOf(Stinrg target, int fromIndex)
public int length()
public String[] split(String regex)
public String substring(int beginIndex)
public String substring(int beginIndex, int endIndex)
public char[] toCharArray()
public String toLowerCase()
public String toUpperCase()
public String replace(char oldChar, char newChar)
public String replace(String oldString, char newString)
public static String valueOf(Object obj)

publica class TestStringMethod{
  public static void main(String[] args){
    String name = "Bob";
    
    char res = name.charAt(2); //b
    
    
    String a = "abc";
    String b = "abd";
    a.compareTo(b); //1表示a大于b， -1表示a小于b， 0表示相等
    
    //测试是否以某个字符串正则表达式所描述的开头或结尾的方法
    String email = new String("abc@edu.com");
    email.endsWith(".com"); //true，判断是否以.com结尾
    
    //去掉空格的trim方法，注意只能去掉开头和结尾的空格
    String t = "  a  ";
    String newT = t.trim(); //"a"
    
    
    //对象的indexOf查找目标
    int index = email.indexOf('@'); //3
    
    String lNames = "a,b,c"
    Stirng[] charArray = lNames.split(","); //注意split中的string会被丢弃
    
    //substring
    String str2 = new String("0123456789");
    str2.substring(3); //3456789
    str2.substring(0,4); //0123,只包括开头，不包括结尾
    
    //将字符串转为char数组
    char []chars = "0123456789".toCharArray();
    
    //字符串包含方法
    String name2 = "A.b";
    name2.contains("."); //true
    
    //字符串替换方法
    String color = "blue";
    color.replace('u', 'l'); //blle
    color.replace("blue", "yellow");
    
    //静态方式构建字符串对象
    String dest3 = String.valueOf(new Boolean(true)); //字符串的true
  }
}


//StringBulider执行效率高，但是多线程不安全

//StringBulider创建
public StringBuild()
public StringBuild(int capacity)
public StringBuild(String str)
public StringBuild(CharSequence seq)

class TestStringBuilder{
  void testCreateStringBuilder(){
    StringBuilder builder = new StringBuilder();
    builder.toString();
    bulider.length();
    bulider.capacatiy();
  }
}


//StringBuilder常用方法
public StringBuilder append(Object obj)
public StringBuilder delete(int start, int end)
public StringBuilder deleteCharAt(int index)
public StringBuilder insert(int setoff, Object obj)
public StringBuilder replace(int start, int end, String str)


void testAppendMethod(){
  StringBuilder builder = new StringBuilder("Hi!");
  StringBuilder builder2 = builder.append(123): //Hi!123
  builder == builder2; //true 直接在原来的builder上进行了append
}

void testDeleteMethod(){
  Sring res = StringManagement.testDelete("0123456789", 7, 9); //01234569包括头，不包括尾
}

void testReplaceMethod(){
  String target = "a=1";
  String res = StringManagement.testReplace(target, ":"); //a:1
  
}

void testInsertMethod(){
  String target = "age:,name:Z";
  String res = StringManagement.testInsert(target, "age:,", 18); //a:1
  
}

public class StringManagement{
  public static String testDelete(String res, int strat, int end){
      StringBuilder builder = new StringBuilder(res);
      builder.delete(start, end);
      return builder.toString();
    }
    
    
    //将"="替换成"："
    public static String testReplace(String res, String replace){
      StringBuilder builder = new StringBuilder(res);
      if(builder.toString().contains("=")){
        builder.replace(builder.indexOf("="), builder.indexOf("=") + 1, replace)；
        return StringManagement.testReplace(builder.toString(),replace);
      }
      return builder.toString();
    }
    
    //age:,插入18
    public static String testInsert(String res, String tag, Object inserObj){
      StringBuilder builder = new StringBuilder(res);
      if(builder.toString().contains(tag)){
        int insertTag = builder.indexOf(tag) + 4;
        builder.insert(insertTag, insertObj);
        return StringManagement.testInsert(builder.toString(), tag, inserObj);
      }
      return builder.toString();
    }

}

//append实现数据库select的拼写
public class StaffDao{
  public void findByArgs(Map<String, Object> args){
    StringBuilder sqlBul = new StringBuilder("select * from staff ");
    if(args.size() != 0){ 
    sqlBul.append("where 1=1");
    if(args.containsKey("name") != null){
      sqlBul.append("and name = " + args.get("name"))
    }
  }
   System.out.println(sqlBul.toString());
}

void testSql(){
  Map<String, Object> map = new HashMap<String, Object>();
  new StaffDao().findByArgs(map); //select * from staff
  map.put("name", "King");
  new StaffDao().findByArgs(map);//select * from staff where name = King
} 


//Date类

//Date对象的创建
public Date()
public Date(long date)

//Date尚未废除的方法
//public boolean after(Date when)
//public boolean before(Date when)
//public int compareTo(Date anotherDate)
//public long getTime()
//public void setTime(long time)
//public String toString() 星期 月份 天 hh:mm:ss 时区 年

public class Employee{
  private String name;
  private Date birth;
  
  public void setName(String Name){
    this.name = name;
  }
  
  public void getName(){
    return name;
  }
  
  public void setBirth(String Birth){
    this.birth = birth;
  }
  
  public void getBirth(){
    return birth;
  }
  
  public Employee(String name. Date birth){
    this.name= name;
    this.birth = birth;
  }
  public Employee(){
  }
}


public class DateSupport{
  pubilc Employee createEmp(String name, Date birth){
    return new Employee(name, birth);
  }
  
  public String eqEmpBirth(Employee e0, Employee e2){
    return e0.getBirth().after(e2.getBirth()) ? e0.getName() + "比" + e2.getName() + "出生早" : e0.getName() + "没有" + e2.getName() + "出生早";
  }
  
  //对给定的date对象实现时间运算，tag大于0则增加num毫秒，小于0减少num毫秒
  public Date changeDate(Date date, long num, int tag){
    if(tag > 0){
      date.setTime(date.getTime() + num);
    }else{
      date.setTime(date.getTime() - num);
    }
    
    return date;
  }
}



class TestCase{
  DateSupport ds = new DateSupport();
  @Test
  void testcreateEmp(){
    String name = "Bob";
    Date birth = new Date();
    Employee emp = ds.createEmp(name, birth);
    emp.getName();
    emp.getBirth();//输出的方式很奇怪，所以一般不用了
    }
    
    void testEqEmpBirth(){
      Employee e0 = new Employee("Bob", new Date(new Date().getTime() - 100000));
      Employee e2 = new Employee("Alice", new Date(new Date().getTime() - 100));
      ds.eqEmpBirth(e0, e2); //Bob没有Alice出生早
      
    }
    
    void testChangeTime(){
      Date d0 = new Date(12345678)；
      int tag = 2;
      long num = 10000;
      Date d2 = ds.changeDate(d0, num, tag); //12355678
      d0.getTime(); //12355678,会覆盖原来的对象
      d0 == d2; //true
    }
    
    void testToStringForDate(){
      Date d0 = new Date(12345678222889L); //L是long的后缀
      d0.toString(); //Wed Mar 22 03:03:42 CST 2361
    }
}



//DateFormat 日期格式化
DateFormat.getDatelnstance() //获取DateFormat实例
 @Test
void useDateFormat (){
  Date d0 = new Date(12345678222889L);
  DateFormat df = DateFormat.getDateInstance();   //抽象类，不能直接实例化。可以用提供的静态方式实现构建
  df.format(d0); //1973-11-30
  
  //使用给定的格式化构建DateFormat
  

  DateFormat df2 = DateFormat.getDateInstance(DateFormat.MEDIUM);
  DateFormat df3 = DateFormat.getDateInstance(DateFormat.MONTH_FIELD);
  DateFormat df4 = DateFormat.getDateInstance(DateFormat.FULL);
  
  //以不同样式格式化日期对象

  df2.format(d0); //1970-5-24
  df3.format(d0); //1970-5-24
  df4.format(d0); //1970年5月24日 星期日
}


//SimpleDateFormat类
public SimpleDateFormat() //yy-M-dd ah:m (上下午，小时，分钟)
public SimpleDateFormat(String pattern)
public SimpleDateFormat(String pattern, Locale locale) //用来考虑不同国家

public class FormatDateManagment{
  
}

@Test
void testUseSimpleDateFormat(){

  //默认形式格式化日期对象
  Date d0 = new Date(12345678222889L);
  SimpleDateFormat sdf0 = new SimpleDateFormat();
  sdf0.format(d0); //70-5-24 上午5:21
  
   //给定格式化日期对象
  SimpleDateFormat sdf2 = new SimpleDateFormat("yyyy/MM/dd a", locale.en);
  sdf2.format(d0); //1970/05/24 AM
}





