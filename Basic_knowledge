\t  =>空格
\n =>换行
\\ =>\符号
\' =>'符号
 
 
 字符串用"", char 用''

import java.util.Scanner;

public class BooleanTest{
  static Scanner in = new Scanner(system.in);
  public static void main(string []args) {
      int num = 0;
      boolean bool;
      System.out.println("Type 0 if you finish your hw, 1 for don't");
      num = in.nextInt();
      if( num == 0) boolean = ture;
      else boolean = false;
  }
}

DataTypeConvert
int num = (int)0.0


char[] 的默认为' '


public修饰的属性可以被任何地方创建的对象直接访问
缺省修饰的属性可以在同一个包内被创建的对象直接访问
private修饰的属性只可以在本类中访问

static修饰的属性是类属性，属于类的特征，其值被所有属于此类的对象共享
static属性规范使用类名进行访问
Student.feature
student.feature //不提倡


构造方法的第一作用是用来创建对象
使用带参数的构造器实现在创建对象时对其进行初始化（为成员属性赋值）
this关键字在构造器及实例方法，代表指向当前对象（当局部变量和成员变量名称相同时必须用this）
public class Employee{

  private Sring name;
  private int age;
  
  public Employee(String name){ //构造器
    this.name = name;
  }
  
  public Employee(String name, int age){ 
    this.name = name;
    this.age = age;
  }
  
  public Employee(){ //公共无参构造器

  }
  
  public void intro(){//method
    System.out.println("I'm " + name);
  
  }
  
}


public class Test{
  public static void main(String[] args){
    Employee e1 = new Employee("张三");
    e1.intro();
  }

}



//使用实例方法例子

public class Dog{
  private String color;
  public Dog(String c){color = c};//构造器。可以创建新的对象，并通过带参数的构造器进行初始化。
  public viod setColor(String c){ this.color =  c;} //使用公共的set方法实现对私有属性进行设置值
  public String getColor(){return this.color;}//使用公共的get方法实现对私有属性的获取

} 
public class DataManger{
    public void changeColor(Dog dog){
        dog.setColor("Black");
    }
}

public class TestDog{
    public static void main(String[] args){
        Dog dog = new Dog("Brown");
        
        System.out.println(dog.getColor()); //此时未改变颜色，为棕色
        dog.changeColor(dog);
        System.out.println(dog.getColor()); //此时未改变颜色，为黑色
    }

}


//使用静态方法
public class AreaProvider{
    private int n;
    
    public static double countArea(double h, double d){ 
    System.out.print(n); //错误，静态方法（类方法）不允许访问实例属性，不能调用实例方法，不能使用this关键字
    int n = 0;
    System.out.print(n); //正确，方法之内声明的变量不属于成员实例属性
    return h * d;
    
    }
}

public class TestStaticMethod{
    AreaProvider.countArea(34.5, 123.78);
    
    AreaProvider area1 = new AreaProvider();
    area1 = countArea(23, 24); // 不推荐，不使用实例访问静态方法
    
}


//方法重载，与访问修饰符，是否静态，返回类型无关
public class AreaProvider{
    private int n;
    
    public static double countArea(double h, double d){ 
    return h * d;
    } //长方形面积
    public static double countArea(double h, double a, double b){ 
    return (a + b) * h / 2;
    }//梯形面积
    public static double countArea(double r){ 
    return Math.pi*r*r;
    }
}

//继承
final不能被继承


//创建一个父类computer
public class Computer{
  private Sting name;

  public double count(double a, double b){return a + b;}
  
  public Computer(){}
  
  public Computer(String name){this.name = name;}//当创建了一个有参构造器时，默认的无参构造器会被覆盖
  
  public String getName(){return name;}//通过public的get方法得到private的name
  
  private void show(){System.out.println("I'm " + name);}
  
  public static void staticMethod() {System.out.println("This is stasic Method");}
  
}


//创建第一个子类Watch
public class Watch extends Computer{

   public Watch(String name){
    //System.out.println(name); // 报错。没有执行super时子类构造还没有调用父类构造器，因此子类构造器还没有产生
    super(name); //子类中的构造器super关键字永远是调用父类中的构造器，从而创建父类构造器
    //System.out.println(name); //正确。super关键字必须位于子类构造器的第一行
   }
   
   public void displayTime(){
      System.out.println(new SimpleDateFormat("yyyy-MM-dd").format(new Date()));
   }
   //重写
   @override
   public double count(double n, double m){//访问修饰符不得低于父类，返回类型，方法名，参数类型，参数数量不得改变。对于final类型的方法不能重写。
      double res = supper.count(n, m);//加上了super关键字，则访问父类的count。否则会访问子类的count，从而导致死循环。
      return (n - m)/res; //最终结果是(n - m)/(n + m);
   }
   
   //静态方法的覆盖
   public static void staticMethod() {
      super.staticMethod();//报错，super不允许出现在static中
      Computer.staticMethod();//正确。子类的静态方法中使用父类类名，可以访问父类资源。
      System.out.println("New stasic Method");
   }
}

//创建一个子类MobilePhone
public class MobilePhone extends Computer{
   public void message(String content){
      System.out.println("内容： " + content);
   }

}


//对于Wacth的测试
public class Test{
  public static void main(String[] args){
      watch.displayTime();
      watch.count(1.1, 2.2); // 3.3
      Watch watch = new watch("字节");
      System.out.println(watch.getName()); //字节
      Watch.staticMethod();//正确。静态方法可以通过类方法调用。如果子类中覆盖了父类的类方法，则调用子类的类方法
  }

}


//对于MobilePhone的测试
public class Test2{
  public static void main(String[] args){
      Computer computer = new MobilePhone(); //上转型对象（实例是子类的，类型是父类的）
      System.out.println(computer.count(23, 45);) //68 上转型对象可以直接调用父类中的方法
      computer.message("Hello"); //报错。因为上转型对象不能访问子类中新添加的属性和方法
      ((MobilePhone)computer).message("Hello");//正确。上转型对象可以强制转换为实际的子类类型
      
      MobilePhone mp = new MobilePhone();
      mp.messagee("Hello"); //正确
      
      mp.show();//错误。 show方法在父类中为private，子类无法继承。
  }

}


//抽象类，一种用于被继承的类
//抽象父类 Animal
public abstract class Animal{//抽象类中也可以包含非抽象方法
  public abstract void run(); //抽象方法，可以用public和protect，但是不能用private，因为private不能被子类调用。
  // 注意： 不能使用final，static。抽象类不能实例化。
}


//普通子类Lion
public class Lion extends Animal{//用普通类继承抽象类时，必须对抽象类的所有方法提供实现
    @override
    public void run(){
      System.out.println("This is a lion");
   } 
}


//抽象子类 Mammal
public abstract Mammal extends Animal{//抽象子类可以不实现父类中的抽象方法，也可以对抽象方法进行实现
    public abstract void lactation();//在抽象子类中可以继续添加新的抽象方法，也可以添加非抽象方法

}

//测试
public class TestAbstract{
    public static void main(Spring[] args){
        Animal animal = new Animal(); //错误。抽象类自身不能实例化
        Animal animal2 = new Lion();//正确。抽象类的实例化属于上转型对象。
        Animal animal2 = new Mammal();//错误
    }
}




//接口
public abstract interface Computer{
    public static final int MAX_NUM = Interger.MAX_VALUE;
    //Java接口只允许定义公共的静态常量，可以省略public static final修饰符
    
    public abstract double count(double a, double b);
    //接口中值允许定义public的抽象方法，可以省略public和abstract
}

//接口的继承
public interface Clock extends Computer{
    void showSystemDateTime();//在子接口中添加了新的抽象定义
}


public class Mulity implements Computer{
    @Override
    public double count(count a, count b){
        return a * b; 
    }
    
    @Override
    public void showSystemDateTime(){
    System.out.print("Time");
    /**
        while(true){
            Date time = new Date();
            String timeString = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(time);
            try{Thread.sleep(1000);}
            catch(InterrutedException e){e.printStackTrace();}
            */
            
        }
    }

}

public TestInterface{
  //Computer computer = new Computer(); //错误。接口自身不能实例化
  Computer computer = new Mulity();//需要借助非抽象的上转型实例化。
  double res = computer.count(2, 3);
  computer.showSystemDateTime();
  System.out.println(res); //6

}




//内部类和局部类

public interface Computer{
  void useComputer(double a, double b);//接口一定是抽象类
}

public class NotebookComputer implements Computer{
    @override//普通类使用接口，要对接口功能进行实现
    public void useComputer(double num0, double num1){
    
        //Memory memory = null; //错误，内部类还未创建
        class Memory{ //局部类不能加访问修饰符，不能加static
            public void store(double a, double b){
                System.out.print("These two numbers are in memory right now")
            }
        }
        Memory memory = new Memory();  //正确，创建局部类对象
        memery.store(num0, num1);
        
        
        Hoard hoard = new NoteBookComputer.Hoard(); //创建了一个本地的静态内部类对象
        hoard.displaySelf();//调用内部静态方法
        //因为私有的静态类只能在本类中使用，所以强行把它写到了接口里
    }
    
    public class Cpu{ //普通内部类
        public void handleData(){
          System.out.println("I'm handlind data!")
        }
    }
    
    private static class Hoard{//私有的静态内部类
        public void displaySelf(){
          System.out.print("This is hoard!")
        }
    }
}

//普通内部类的测试
public class TestInnerClass{
  public static void main(String[] args){
    cpu = new Cpu(); //错误，要先调用外部类
    NotebookComputer nc = new NotebookComputer();
    cpu = nc.new Cpu();//正确，先调用了外部类，再调用内部类
    
    cpu = new New NotebookComputer().new Cpu();//正确。将上面两句合成一句
    
    cpu.handlData(); // I'm handlind data!
    
    //局部类的测试
    nc.useComputer(1,2); //These two numbers are in memory right now  This is hoard!
  }

}

//匿名类

//定义一个职员类，这个职员类可以利用接口进行工作
public class Staff{
    public void useComputerWorking(Computer computer, double n, double m){
        computer.useComputer(n , m);
    }

}

public class TestHiddenClass{
    public static void main(String[] args){
        Staff mark = new Staff();
        double a = 1.0;
        double b = 2.0;
        mark.useComputerWorking(new Computer(){
          @Override
          public void useComputer(double a, double b){
             double res = a + b;
             System.out.print("计算结果是"+res);
          }//匿名类对象
        }, a, b);
        
        //如果不想使用匿名类，可以先对接口进行override，然后使用useComputerWorking来进行Staff的计算
//        Computer computer = new Computer() {
//            @Override
//            public void useComputer(double a, double b) {
//                System.out.print("计算结果是" + (a + b));
//            }
//        };
//        mark.useComputerWorking(computer, a, b);
        
    }
}



//静态块

public class Location{

  public static final int EAST;
  public static final int WEST;
  public static final int SHOUTH;
  public static final int NORTH;
  
  public double distance;
  
  
  static{ //静态代码块，允许赋值和调用静态方法
     EAST = 0;
     WEST = 1;
     SOUTH = 2;
     NORTH = 3;
     display();
     displayDistance(distance); //错误。不能在静态块中引用非静态方法，不能访问非静态字块
     
     class B{} //静态中可以定义内部类
     
     interface B{}//错误，静态块中不许使用接口
  }
  
  public static void display(){
      System.out.println("您的当前默认位置是" + NORTH);
  
  }
  
  private void displayDistance(double distance){
      
  }
  
  public Location(double distance){
    this.distance = distance;
    System.out.println("调用构造器，创建对象");
  }
}


public class TestSta1{
    public static void main(String[] args){
        int location = Location.SOUTH; //您的当前默认位置是3
        int location = Location.EAST;//静态代码块和类的加载只会被加载一次
    }

}


public class TestSta2{
    public static void main(String[] args){
        Location location = new Location(233.33); //您的当前默认位置是3  调用构造器，创建对象
        //静态代码块在静态初始化后与调用构造器之前加载
    }
}


//object类(顶级父类)
public interface BaseInterface{
  Object superMethod(Object obj);//可以存入任何类型
}

public class BaseInterfacesImp implements BaseInterface{
    public Object superMethod(Object obj){
        int []ints = (int[])obj;
        return ints.length > 1 ? ints[0] + ints[1] : 0; //注意要进行强制转换
    }

}

public class Test{
    piblic static void main(String[] args){
        BaseInterface baseInter = new BaseInterfacesImp();
        int []ints = {34, 25}
        int sum = (Integer)(baseInter.superMethod(ints));
        System.out.println(sum); // 59
    }

}



//toString()
public class Users{
    private String id;
    private String name;
    private int age;
    
    public String getId(){
      return id;
    }
    public void setId(String id){
      this.id = id;
    }
    public String getName(){
      return name;
    }
    public void setName(String name){
      this.name = name;
    }
    public void setAge(int Age){
      this.age = age;
    }
    public int getAge(){
      return age;
    }
    public Users(String id, Srting name, int age){
      this.id = id;
      this.name = name;
      this.age = age;
    }
    public Users(){}
    
    @Override
    public String toString(){
      String begin = '{';
      String end = '}';
      
      begin += "\"";
      begin += "id";
      begin += "\"";
      begin += ":";
      begin += this.getId();
      begin += ",";
      
      begin += "\"";
      begin += "name";
      begin += "\"";
      begin += ":";
      begin += this.getName();
      begin += ",";      
      
      begin += "\"";
      begin += "age";
      begin += "\"";
      begin += ":";
      begin += this.getAge();
      begin += end; 
      
      return begin;

    }

}

public class Test2{
    public static void main(String[] args){
        Users u = new Users("NO1", "Bob", 20);
        System.out.println(u.toString()); //{"id":NO1, "name":Bob, "age":69}
    }
}


//equals
public class Employee implements Cloneable{ //为了克隆，必须使用cloneable接口
    private String id;
    private String name;
    public String getId(){
        return id;
    }
    public void setId(String id){
       this.id = id;
    }
    public String getName(){
        return name;
    }
    public String setName(String name){
        this.name = name;
    }
    public Employee(String id, String name){
        this.id = id;
        this.name = name;
    }
    public Employee(){
        
    }
    @Override
    public boolean equals(Object obj){
        Employee emp = (Employee)obj;
        return this.getId().equals(emp.getId()) ? true : false;
    }
    //clone方法
    @Override
    public Employee clone throws CloneNotSupportedException{
        System.out.println("开始克隆");
        return (Employee)super.cione();
    }
}
public class Test3 {
    public static void main(String[] args){
        Employee emp0 = new Employee("123", "Bob");
        Employee emp1 = new Employee("123", "Alice");
        emp0.equals(emp1); //true
    }
}
//getClass方法
public class Test4 {
    public static void main(String[] args){
        Employee emp0 = new Employee("123", "Bob");
        Class empClass = emp.getClass(); 
        //使用class对象获取当前对象的类的完全限定名称
        empclass.getName(); //可以得到类名，比如com.szb.entity
    }
}

//hashCode方法
public class Test5 {
    public static void main(String[] args){
        Users u0 = new Users("NO12", "Jack", 40 );
        Users u1 = new Users;
        User u2 = u0;
        u0.hashCode();
        u1.hashCode();
        u2.hashCode(); //u0和u2应该相同
    }
}

//clone方法
public class Test6 {
    public static void main(String[] args){
        Employee e1 = new Employee("1", "A");
        try{
             Employee cloneEmp = e1.clone();
             System.out.println("当前对象与克隆对象是否相等" + (e1 == cloneEmp)); //false
             System.out.println("当前对象属性" + e1.getId()+"/t"+e1.getName()); //1，A
             System.out.println("克隆对象属性" + cloneEmp.getId()+"/t"+cloneEmp.getName()); //1，A
        }catch(CloneNotSupportedException e){
            e.printStackTrace();
        }
    }
}

//Integer包装类
public final class Employee{
    private Integer id; //使用包装类代替int
    public Employee(Integer id){
        this.id = id;
    }
    public Employee(){
    }
    public Integer getId(){
        return id;
    }
    public Integer setId(Integer id){
        this.id = id;
    }
} 

public class TestInteger{
    public static void main(String[] args){
        Employee emp = new Employee();
        Employee emp2 = new Employee();
        
        Integer intObj = new Integer(24);
        emp.setId(intObj);
        
        Integer intObj2 = new Integer("25");//可以用int，也可以用string
        emp.setId(intObj2);
        
        //compareTo方法比较大小
        emp.getId().compareTo(emp2.getId());           //-1, 因为emp小于emp2
        emp2.getId().compareTo(emp.getId());           //1, 因为emp2大于emp
        new Integer(100).compareTo(new Integer(100));  //0, 因为相等
        
        //intValue方法
        emp.getId().intValue();       //24 
        
        //parseInt方法，将字符串转为值类型。
        String pwd = '123456';
        int pwdInt = Integer.parseInt(pwd);
        
        //parseInt重载方法
        Integer.parseInt("10111", 2)    //此处10111为二进制，用该方法可以转成十进制，为23
        Integer.parseInt("14174", 8)    //6268
        Integer.parseInt("0A8FC", 16)   //43260
        
        
    }
}


Integer.MAX_VALUE //2147483647
Integer.MIN_VALUE //-2147483648
Integer.BYTES    //4
Integer.SIZE     //32

//toBinaryString方法，返回一个二进制的字符串
public static class IntergerParse(){
    public String formIntegerToStringByArg(int target, int tag){
        if(tag == 2) return Integer.toBinaryString(target);
        else if(tag == 8) return Integer.toOctalString(target);
        else if(tag == 16) return Integer.toHexString(target);
        else return Integer.toBinaryString(target);
    }
}

public class TestInteger2{
    public static void main(String[] args){
        int num = 2390;
        IntegerParse.formIntegerToStringByArg(num, 2);    //100101010110
        IntegerParse.formIntegerToStringByArg(num, 8);    //4526
        IntegerParse.formIntegerToStringByArg(num, 16);   //956
        IntegerParse.formIntegerToStringByArg(num, 5);    //100101010110
    }
}


//valueOf方法，把给定的参数转化成对象类型
//toString方法
public class TestValueOfMethod{
    public static void main(String[] args){
        int num = 1234;
        Integer intObj0 = Integer.valueOf(num); 
        System.out.println(intObj0.intValue());   //1234。注意，intValue是把Integer转为int
        
        Integer.valueOf("345").intValue;   //Integer.valueOf("345")是把字符串转成integer 
        
        Srting str = "1011010";
        Integer intObj2 = Integer.valueOf(srt, 2); //90.valueOf可以将二进制转为十进制，其实是调用了parseInt方法
        
        Integer intObj = Integer.valueOf(156);
        intObj.toString().length(); //3
        intObj.toString(2);//不提倡。在toString没有参数的时候，是由对象进行调用的（调用的函数没有static）
        Integer.toString(2);//有参数的时候，调用函数有static，是静态重载，应该用类进行调用
        Integer.toString(intObj， 2); //10011100.将intObj转为二进制
    }
}


//Character包装类
public class Test{
    public static void main(String[] args){
        Character charObj = new Character('A');
        Character charObj2 = Character.valueOf('中'); //用静态方式创建
        
        CharacterManager.equal(Character.valueOf('A')， Character.valueOf('B')); //第二个大
    }
}

//Character的实例方法：charValue(), compareTo(), toString()
//compareTo()方法
public static class CharacterManager{ //跟实例无关，只是一个函数就可以使用static
    public String equal(Character ch0, Character ch1{
        if(ch0.compareTo(ch1) == 0) return "相等";
        else if(ch0.compareTo(ch1) == 1) return "第一个大";
        else return "第二个大";
    }
    
    //统计密码中有多少字母，数字，大写字母，小写字母，非数字且非英文字符
    public static void validatePassword(char[] passArr){
      int num0 = 0; //数字
      int num1 = 0; //字母
      int num2 = 0; //大写
      int num3 = 0; //小写
      int num4 = 0; //非数字且非英文字符
      
      for(int i = 0; i < passArr.length; i++){
         if(Character.isLetter(passArr[i])) ++num1;
         if(Character.isDigit(passArr[i])) ++num0;
         if(Character.isUpperCase(passArr[i])) ++num2;
         if(Character.isLowerCase(passArr[i])) ++num3;
         if(!Character.isLetterOrDigit(passArr[i])) ++num4;
      }
    }
    
    //删除空格
    public static String dropSpaceChar(char []passArr){
      String str = "";
      for(int i = 0; i < passArr.length; i++){
        if(!Character.isWhitespace(passArr[i])){
          str + passArr[i];
        }
      }
          return str;
    }
    
     //改成大写or小写
     public static final int UPPER=1;
     public static final int LOWER=0;
    public static char[] toUpperCaseOrLowerCase(char []passArr, int tag){
      for(int i = 0; i < passArr.length; i++){
        if(tag == UPPER){ //当tag为1的时候，即为UPPER，需要改成大写
          passArr[i] = Character.toUpperCase(passArr[i]);
        }
        else passArr[i] = Character.toLowerCase(passArr[i]);
      }
          return passArr;
    }
}


//Character的静态方法：isDefined(int ch), isDigit(int ch), isLetter(int ch), isLetterOrDigit(int ch), isLowerCase(int ch), isUpperCase(int ch), isWhitespace(int ch), toLowerCase(int ch), toUpperrCase(int ch)
public class Test2{
    public static void main(String[] args){
       char []pwd = {'T','9','0','x',' ','_','4,'n'};
       
       CharacterManager.validatePassword(pwd);
       
       CharacterManager.dropSpaceChar(pwd);
       
       System.out.print(new String(CharacterManager.toUpperCaseOrLowerCase(pwd, CharacterManager.LOWER)));
    }
}

