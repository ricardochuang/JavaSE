File(File dir, String child)
File(String pathName)
File(String parent, String child)
File(URI uri)

//构造器
public class Test{
    public static void main(String[] args){
        File file0 = new File("d:/files/carnames.txt"); //文件其实并不存在，但是可以这样操作，file对象不是null
        file0.exists(); //False
        
        File dir = null; //文件的父路径
        File file2 = new File( dir, "d:/files/carnames.txt"); 
        
        //URI作为构建File对象的参数，必须保证其字符串描述前缀，且路径分隔符必须是/
        URI uri = new URI("file:/files/");
        File file3 = new File(uni);
    }
}


//类常用方法
public boolean canWrite()
public boolean canRead()
public boolean creatNewFile() throws IOException
public boolean delete()
public boolean exists()
public String getAbsolutePath()
public String getName()
public String getParent()
public String getPath()
public String isDirectory()
public boolean isFile()
public File[] listFiles()
public boolean mkdir()  //创建目录
public boolean mkdirs()


public class FileSupport{
        //根据给定的filePath创建File对象并返回
        public static File createFile(Srting filePath){
                return new File(filePath);
        }
        public static void displayFileInfo(File file) throws IOException{
                System.out.println(file.canRead() ? "可以读取" : "不可读");
                System.out.println(file.canWrite() ? "可以写" : "不可写");
                System.out.println(file.exists() ? "此文件存在" : "文件不存在");
                System.out.println(file.delete() ? "文件已经删除" : "删除失败");
                System.out.println(file.createNewFile() ? "创建成功" : "创建失败");
        }
}


public class Test2{
        public static void main(String[] args){
                Stirng filePath = "d:/files.doc\\carnames.txt";
                File file = FileSupport.createFile(filePath);
                
                try{
                    FileSupport.displayFileInfo(file);
                }catch(IOException e){
                    e.printStackTrace();
                }
        }
}


public int countFileAndDirSumInFile(File dir){
        if(dir.isDirectory()){//如果是目录
              return dir.list().length;  
        }
        return 0;
}

publlic static boolean createFolder(String dirPath){
        boolean bool = false;
        File dir = new File(dirPath);//构建File
        bool = dir.mkdir(); //如果预想创建目录成功，则必须保证当前目录的N级所有父路径都存在
        bool = dir.mkdirs(); //无论当前欲创建的目录N级父路径是否存在，则都会成功。如果某个父目录不存在，首先创建依赖的父目录
        return bool;
}


字节输入流主要方法
public abstract int read()throws IOException //返回的是拿到的字节的量
public int read(byte[] b)throws IOException //可以拿到字节，放到缓冲区缓存
public int read(byte[] b, int off, int len)throws IOException
public int close()throws IOException

public class FileInAndOutSupport{
    public static void testRead(File file){
        if(file.exists()){
        InputStream in = null;
            try{
                in = new FileInputStream(file);
                int count = 0; //记录读取一个字节返回的int字节值
                while( count = in.read()!= -1 ){
                    System.out.println(count);
                }catch(FileNotFoundException e){
                    e.printStackTrace();
                }catch(IOExcepttion e){
                    e.printStackTrace();
                }finally{
                    in.close(); //关闭输入流，释放资源
                }
                
            }
        }
    }
}


in = new FileInputStream(file);
byte [] bys = new byte[6]; //作为读取字节数据的临时缓冲区
int count = 0; //记录实际读取的并填充缓冲区的实际字节数
while( (count = in.read(bys)) != -1 ){ //count = in.read(bys, 0, by.length)
    String str = new String(bys, 0, count);
    System.out.println(str);
}

二进制缓冲输入流
public static long useBufferInputStream(File file){
    long size = 0;
    if(file.exits()){
        InputStream in = null;
        BufferedInputStream bin = null; //缓冲流
        try{
            in = new FileInputStream(file); //建立基于文件的普通输入流
            bin = new BufferedInputStream(in); //基于二进制输入流建立缓冲流
            byte [] bys = new byte[1024*10]; //临时缓冲区
            int count = 0;
            while((count = bin.read(bys, 0, bys.length)) != -1){
                size += count; //累加实际读取到的字节数
            }
        }catch(IOException e){
            e.printStackTrace();
        }finally{
            bin.close();
            in.close();
        }
        return size;
    }
}


字符输入流
主要方法
public int read() throws IOException
public int read(char[] cbuf) throws IOException
public abstract int read(char[] cbuf, int off, int len) throws IOException
public void close() throws IOException


使用文本流读取文本文件
public static void useCharInputStream(File file){
    if(file.exists()){
        Reader reader = null;
        try{ 
            reader = new FileReader(file);
            char chs = new char[124];//文本缓冲区
            int count = 0;
            while((count = reader.read(chs, 0 ,chs.length)) != -1){
                System.out.println(new String(chs, 0, count));
            }
        }catch(IOException e){
            e.printStackTrace();
        }finall{
            reader.close();
        }
    }
}

按行读取信息
public static List<User> readUserInforFromFile(File userFile){
    List<User> users = new ArrayList<>();
    if(userFile.exits()){
        Reader r = null;
        BufferedReader br = null;
        try{
            r = new FileReader(useFile);
            br = new BufferedReader(r);
            String lineStr = ""; //临时存储读取到的单行字符串
            while((lineStr = br.readLine()) != null && !lineStr.equals("")){//使用文本缓冲流按行进行循环读取
                User user = new User();
                String [] strs = lineStr.split(" "); //按照空格拆分字符串
                user.setId(strs[0]);
                user.setName(strs[1]);
                user.setGenger(strs[2]);
                user.setBirth(new SimpleDateFormat("yyyy-MM-dd").parse(strs[3]));
                user.setGenger(strs[4]);
                
                users.add(user);
            }
        }catch(IOException e){
            e.printStackTrace();
        }finally{
            br.close();
            r.close();
        }
    }
    return users;
}


